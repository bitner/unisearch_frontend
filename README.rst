unisearch_frontend
==================

This repo contains frontend components which can be used to construct
browser-based UIs for searching GeoNode and/or Registry, using their APIs.

The code is written in TypeScript. The provided Webpack configuration uses the
TypeScript compiler to create minified ES5 which can be run in browsers as part
of a frontend application. So the source is in TypeScript, but the product runs
in browsers where only JavaScript is supported.

This code can be included in other projects, e.g. in 
`unisearch_django <https://github.com/harts-boundless/unisearch_django>`_,
which can simply provide and use these frontend components. They could even be
served statically, since this is just a frontend app and these are just
components.


Working with Git and GitHub
---------------------------

First, fork the repo on GitHub. This fork on GitHub is where you will
push any branches you might use to PR against the project. In git, your fork
will be the remote named `origin`.

Second, clone from your fork to your local machine. Doing this will
automatically set the remote named `origin` to point at your fork, so that you
can push branches to it easily.
For example, if your username is `sallyjenkins` you'd use::

    git clone git@github.com:sallyjenkins/unisearch_frontend

If you want to track updates or make PRs, you'll want to add an upstream::

    git remote add upstream git@github.com:boundlessgeo/unisearch_frontend

Then, whenever you want to see the latest updates, you can use::

    git fetch upstream

Then, to compare your current branch with the latest::

    git diff upstream/master

Or to rebase your branch to prepare for a PR against `upstream`::

    git rebase upstream/master

Whenever you want to make a PR on GitHub, make a branch to contain your work.
Then you can push it to your `origin` (don't push to `upstream`). Always
remember to fetch and rebase before pushing your branch. Example workflow::

    git checkout -b mycoolbranch
    git commit -am "show off my cool commit message"
    git fetch
    git rebase upstream/master
    git push origin mycoolbranch

Once that is done, you can use the GitHub interface to make a PR.


Installing Dependencies
-----------------------

You will also need node and npm installed on your local machine. As of this
writing, I was using node 4.2.6 and npm 3.5.2, from the Ubuntu repositories,
but others should probably work. If you don't already have them, ask Google how
to install them for your OS. (On Ubuntu, the default packages install with the
executable `nodejs`. You want the package `nodejs-legacy` to ensure you get a
symlink in `/usr/bin/node`. If you can't run `node` at the command line, things
aren't set up right.)

You will also need TypeScript, which wants to be installed as follows::

    npm install -g typescript

Without this step, the app may appear to build, but complain about missing
modules.

You will need to install the app's dependencies, from the repo directory, with::

    npm install

However, after the first time you've done this, you don't need to do it again
unless you remove the `node_modules` directory it creates.

If anything in this procedure doesn't work, and you know it's not the fault of
some change you made, then please file a bug on GitHub.


Running the App
---------------

If you want to try the components locally in your browser, use::

    npm start

This launches webpack-dev-server to serve  a page at http://localhost:8080.
This page is autogenerated using the template file ./index.html, which has no
other use than interactive testing.

webpack-dev-server also watches for changes in your files, and rebuilds as
necessary. However, note that the build output is kept in memory, so you will
not find it on disk. If you want to see the build output, you can either View
Source in your browser, or use `npm run build`.

The configuration for this build (as well as production builds) is in
`webpack.config.js`.


Running Unit Tests
------------------

To run unit tests::

    npm test

This launches karma, which watches files and runs unit tests in real browsers,
building TypeScript as needed. Its configuration is in `karma.conf.js`, which
contains my bugs that can often be blamed for mysterious unit test failures.

If you make a lot of changes to the files or directory structure, karma tends
to throw an exception or produce confusing errors, so if you do any major
surgery and you want to see unit test output, you should probably restart karma
manually every now and then.


Building Output
---------------

To make a build::

    npm run build

This uses webpack to create bundle files in `dist/`. Again, the configuration
for this is in `webpack.config.js`.

The files from `dist/` can be put wherever you want, then referenced from HTML
code in order to use the components from this repo.


Repository Layout
-----------------

The root of the directory contains various configuration files. After you have
run `npm install` it will also contain a directory `node_modules` which
contains downloaded dependencies. If you have run a build, it will also contain
a directory `dist` which contains build output.

`./core` contains a set of adapters for different HTTP search APIs. Each
adapter is I/O-free, and presents the same interface as every other adapter. It
defines how to translate a common query representation (Query) into a
lightweight specification of an HTTP request (Request) against a particular
kind of API. It also provides a parser which translates a "raw" object (e.g.
the result of parsing a JSON response body from the given API) into a common
result representation (Result). All these interface definitions are also part
of the core.

Other directories contain UI components for use in different frontend
environments (e.g. Angular, React). Each of these creates DOM elements, handles
input events, and performs I/O, but delegates all API specifics to the core. It
asks the core what Request it needs for a particular Query, executes that
request, handles any errors, asks the core how to interpret any successful
response (as a Result); then makes any appropriate UI updates.

This abstraction makes it possible to use any combination of API and UI.

For now, only UI code is in `./angular1`, which is written with Angular 1.5. In
the future, it just depends on where we'll need to use this.
